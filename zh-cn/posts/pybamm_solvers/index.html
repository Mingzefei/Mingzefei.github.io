<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title> - Mingzf 的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/zh-cn" title="Mingzf 的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">Mingzf 的博客</div>
					
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/zh-cn/posts">
				
				<span class="menu__text">日志</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/zh-cn/about/about">
				
				<span class="menu__text">关于</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/zh-cn/about/my_cv">
				
				<span class="menu__text">简历</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/en">
				
				<span class="menu__text">English</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-26Y8LPEFKG"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-26Y8LPEFKG');
    </script>
</header>

		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title"></h1>
			
		</header>
		
<div class="post__toc toc">
	<div class="toc__title">目录</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#1-求解器的角色与重要性">1. 求解器的角色与重要性</a></li>
    <li><a href="#2-pybammsolver-基类与核心概念">2. <code>pybamm.Solver</code> 基类与核心概念</a></li>
    <li><a href="#3-pybamm-中集成的求解器">3. PyBaMM 中集成的求解器</a>
      <ul>
        <li><a href="#31-casadi-solver-pybammcasadisolver">3.1. CasADi Solver (<code>pybamm.CasadiSolver</code>)</a></li>
        <li><a href="#32-scipy-solver-pybammscipysolver">3.2. SciPy Solver (<code>pybamm.ScipySolver</code>)</a></li>
        <li><a href="#33-sundials-solvers-via-scikitsodes">3.3. SUNDIALS Solvers (via scikits.odes)</a></li>
      </ul>
    </li>
    <li><a href="#4-求解过程详解">4. 求解过程详解</a></li>
    <li><a href="#5-求解器选择与配置">5. 求解器选择与配置</a></li>
    <li><a href="#6-常见问题与考量">6. 常见问题与考量</a></li>
    <li><a href="#7-设计考量与-github-讨论">7. 设计考量与 GitHub 讨论</a></li>
    <li><a href="#8-总结">8. 总结</a></li>
  </ul>
</nav>
	</div>
</div><div class="content post__content clearfix">
			<h1 id="pybamm-核心子系统数值求解器-solvers">PyBaMM 核心子系统：数值求解器 (Solvers)</h1>
<p><strong>返回主目录:</strong> <a href="./pybamm_main.md">PyBaMM 项目剖析</a>
<strong>上一节:</strong> <a href="./pybamm_discretisation.md">空间方法与离散化 (Spatial Methods &amp; Discretisations)</a></p>
<hr>
<p>在模型被成功离散化为一组常微分方程 (ODEs) 或微分代数方程 (DAEs) 之后，下一步就是利用数值求解器 (Solvers) 来计算这些方程在给定时间跨度内的解。PyBaMM 提供了一个灵活的求解器框架，集成了多种先进的数值求解库，并允许用户根据模型特性和求解需求进行选择和配置。</p>
<p>求解器子系统的主要目标是高效且准确地计算出模型变量（如电势、浓度、温度等）随时间的变化。</p>
<h2 id="1-求解器的角色与重要性">1. 求解器的角色与重要性</h2>
<p>数值求解器是连接数学模型与可量化预测的桥梁。对于电池模型这类通常包含复杂、非线性且可能具有多尺度特性的方程组，求解器的选择和配置对以下方面至关重要：</p>
<ul>
<li><strong>准确性 (Accuracy):</strong> 求解器必须能够以足够高的精度逼近真实解。</li>
<li><strong>稳定性 (Stability):</strong> 对于某些“刚性”(stiff) 系统（即系统中包含变化速率差异很大的过程），求解器需要具备特定的稳定性才能有效求解。</li>
<li><strong>效率 (Efficiency):</strong> 求解速度直接影响参数研究、优化设计和实时仿真的可行性。</li>
<li><strong>鲁棒性 (Robustness):</strong> 求解器应能处理各种模型参数和初始条件，并给出合理的反馈。</li>
</ul>
<p>PyBaMM 的求解器接口 (<code>src/pybamm/solvers/</code>) 旨在封装不同求解库的复杂性，提供统一的调用方式。</p>
<h2 id="2-pybammsolver-基类与核心概念">2. <code>pybamm.Solver</code> 基类与核心概念</h2>
<p>所有PyBaMM中的求解器都继承自 <code>pybamm.BaseSolver</code> 类 (位于 <code>src/pybamm/solvers/base_solver.py</code>)。这个基类定义了求解器应具备的核心功能和接口，例如：</p>
<ul>
<li><code>__init__(self, method=None, rtol=1e-6, atol=1e-6, ...)</code>: 初始化求解器，设置通用参数如求解方法、相对和绝对容差等。</li>
<li><code>solve(self, model, t_eval, external_variables=None, inputs=None, ...)</code>: 核心求解方法，接收一个离散化后的 <code>model</code> 对象和求解时间点 <code>t_eval</code>，返回一个 <code>Solution</code> 对象。</li>
<li><code>step(self, model, dt, npts=2, external_variables=None, inputs=None, ...)</code>: （如果支持）单步求解方法，用于更细致的控制或与其他代码的集成。</li>
<li><code>calculate_consistent_initial_conditions(self, model, initial_conditions, inputs)</code>: 对于DAE模型，在求解开始前计算一组一致的初始条件。</li>
</ul>
<p><strong>关键概念:</strong></p>
<ul>
<li><strong>ODE (Ordinary Differential Equation):</strong> 形如 <code>dy/dt = f(t, y)</code> 的方程。</li>
<li><strong>DAE (Differential-Algebraic Equation):</strong> 形如 <code>F(t, y, dy/dt) = 0</code> 的方程，是ODE的推广，包含代数约束。许多电池模型自然地以DAE形式出现。</li>
<li><strong>刚性 (Stiffness):</strong> 指系统中不同组分的时间尺度差异巨大。刚性问题需要使用隐式求解器以保证稳定性。</li>
<li><strong>雅可比矩阵 (Jacobian):</strong> <code>df/dy</code> (对于ODE) 或 <code>dF/dy</code> 和 <code>dF/dy'</code> (对于DAE) 的偏导数矩阵。它对于许多高效的隐式求解器至关重要。PyBaMM能够自动计算模型的符号雅可比，并将其编译成高效代码。</li>
<li><strong>事件 (Events):</strong> 在求解过程中，当某个特定条件（如电压达到某个阈值）满足时触发的动作。PyBaMM使用事件来确定实验的终止条件。</li>
</ul>
<h2 id="3-pybamm-中集成的求解器">3. PyBaMM 中集成的求解器</h2>
<p>PyBaMM 集成了多种求解器，用户可以根据需求选择。</p>
<h3 id="31-casadi-solver-pybammcasadisolver">3.1. CasADi Solver (<code>pybamm.CasadiSolver</code>)</h3>
<ul>
<li><strong>默认求解器，强烈推荐。</strong> 个人认为，这主要是因为 CasADi 提供了符号计算的强大能力，可以将模型和雅可比矩阵转换为高效的C代码进行编译和求解，这对于复杂电池模型通常能带来显著的性能优势。</li>
<li>位于 <code>src/pybamm/solvers/casadi_solver.py</code>。</li>
<li>利用 CasADi 框架进行符号计算和高效的代码生成 (C代码)。</li>
<li>支持ODE和DAE模型。</li>
<li>内部使用 SUNDIALS 的 IDA (用于DAE) 和 CVODES (用于ODE) 求解器作为后端，但通过CasADi的接口调用。</li>
<li><strong>优点:</strong> 速度快，鲁棒性好，能有效处理刚性问题和大型DAE系统，支持精确的灵敏度分析。</li>
<li><strong>模式 (<code>mode</code>):</strong>
<ul>
<li><code>&quot;safe&quot;</code> (默认): 包含更多检查和后处理步骤。</li>
<li><code>&quot;fast&quot;</code>: 更快的求解，但可能牺牲一些鲁棒性。</li>
<li><code>&quot;fast with events&quot;</code>: 快速模式，同时处理终止事件。</li>
</ul>
</li>
</ul>
<h3 id="32-scipy-solver-pybammscipysolver">3.2. SciPy Solver (<code>pybamm.ScipySolver</code>)</h3>
<ul>
<li>位于 <code>src/pybamm/solvers/scipy_solver.py</code>。</li>
<li>使用 SciPy 库中的 <code>solve_ivp</code> 函数。</li>
<li>支持多种ODE求解方法，如 <code>RK45</code>, <code>RK23</code>, <code>DOP853</code>, <code>Radau</code>, <code>BDF</code>, <code>LSODA</code>。</li>
<li><strong>优点:</strong> 易于使用，是Python生态系统的一部分。对于一些非刚性或规模较小的ODE问题，它是一个方便快捷的选择。个人推测，它也被包含在内以提供一个纯Python的求解选项，减少对外部编译器的依赖（尽管CasADi的性能优势通常更受青睐）。</li>
<li><strong>缺点:</strong> 对于大型或非常刚性的DAE问题，可能不如CasADi/SUNDIALS高效或鲁棒。主要用于ODE。</li>
</ul>
<h3 id="33-sundials-solvers-via-scikitsodes">3.3. SUNDIALS Solvers (via scikits.odes)</h3>
<p>PyBaMM 也曾直接通过 <code>scikits.odes</code> 包提供了对 SUNDIALS 求解器的接口，但 <code>CasadiSolver</code> 现在是首选的与 SUNDIALS 交互的方式，因为它提供了更好的性能和灵活性。</p>
<ul>
<li><code>pybamm.IDAKLUSolver</code> (已不常用，CasADi替代): 基于SUNDIALS IDA求解器，使用KLU稀疏线性求解器。</li>
<li>其他基于 SUNDIALS 的求解器（如 CVODES）现在主要通过 <code>CasadiSolver</code> 间接使用。</li>
</ul>
<h2 id="4-求解过程详解">4. 求解过程详解</h2>
<p>求解器与离散化后的模型紧密协作，将数学方程转化为可计算的数值结果。以下是详细的求解流程：</p>
<ol>
<li>
<p><strong>接收离散化模型</strong>: 求解器接收一个已经由 <code>Discretisation</code> 类处理过的模型。这个模型包含了所有方程（右端项 <code>rhs</code> 和代数约束 <code>algebraic</code>）的离散形式，以及初始条件和边界条件。</p>
</li>
<li>
<p><strong><code>solve</code> 方法</strong>:</p>
<ul>
<li><strong>输入</strong>:
<ul>
<li><code>model</code>: 经过离散化的模型对象。</li>
<li><code>t_eval</code>: 一个包含求解时间点的一维数组。求解器将计算在这些时间点上的解。</li>
<li><code>external_variables</code> (可选): 用于驱动仿真的外部变量，例如电流、温度等。</li>
<li><code>inputs</code> (可选): 传递给模型的参数值。</li>
</ul>
</li>
<li><strong>核心操作</strong>:
<ul>
<li><strong>一致性初始条件计算</strong>: 对于DAE模型，求解器首先会调用 <code>calculate_consistent_initial_conditions</code> 方法。这一步确保了在 <code>t=0</code> 时，所有代数方程都得到满足，并且微分变量的初始值与代数变量相一致。这对于避免求解初期的数值振荡和保证求解的稳定性至关重要。</li>
<li><strong>主求解循环</strong>: 求解器根据选定的数值方法（如BDF、Adams、Runge-Kutta等）和时间步长控制策略，在 <code>t_eval</code> 指定的时间点上逐步推进求解。
<ul>
<li><strong>雅可比矩阵</strong>: 对于隐式方法，求解器会利用模型提供的雅可比矩阵（如果可用且求解器支持）来加速牛顿迭代等非线性求解过程，从而提高收敛速度和稳定性。PyBaMM能够自动计算符号雅可比，并将其编译为高效代码。</li>
<li><strong>事件检测</strong>: 在每个时间步之后，求解器会检查是否有预定义的事件（如电压达到截止电压、电流达到某个值等）发生。如果事件发生，求解器可能会终止或调整其行为。</li>
</ul>
</li>
</ul>
</li>
<li><strong>输出</strong>: <code>pybamm.Solution</code> 对象。</li>
</ul>
</li>
<li>
<p><strong><code>pybamm.Solution</code> 对象</strong>:</p>
<ul>
<li>这是一个包含求解结果的丰富对象，存储了：
<ul>
<li><code>t</code>: 求解的时间点数组。</li>
<li><code>y</code>: 状态向量在每个时间点的解。这是一个二维数组，行对应时间点，列对应状态向量中的不同变量。</li>
<li><code>model</code>: 用于生成此解的模型对象。</li>
<li><code>inputs</code>: 求解时使用的输入参数。</li>
<li><code>termination</code>: 求解终止的原因（例如，“正常完成”、“达到事件”）。</li>
<li><code>t_event</code>, <code>y_event</code>: 事件发生的时间和状态（如果发生）。</li>
</ul>
</li>
<li><code>Solution</code> 对象还提供了便捷的方法来访问和处理结果，例如：
<ul>
<li>通过变量名直接索引解：<code>solution[&quot;Terminal voltage [V]&quot;]</code>。</li>
<li>插值：<code>solution(t)</code> 可以在任意时间点 <code>t</code>（在求解范围内）插值得到解。</li>
<li>绘图：内置了快速绘图功能。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="5-求解器选择与配置">5. 求解器选择与配置</h2>
<p>PyBaMM 提供了灵活的求解器选择和配置机制。</p>
<ul>
<li>
<p><strong>自动选择</strong>: 如果用户不指定求解器，PyBaMM 通常会默认使用 <code>pybamm.CasadiSolver</code>，因为它在大多数情况下表现良好。</p>
</li>
<li>
<p><strong>手动指定</strong>: 用户可以在创建 <code>Simulation</code> 对象时或直接调用 <code>solve</code> 方法时指定求解器实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">solver <span style="color:#f92672">=</span> pybamm<span style="color:#f92672">.</span>ScipySolver(method<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;BDF&#34;</span>, rtol<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-8</span>, atol<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-8</span>)
sim <span style="color:#f92672">=</span> pybamm<span style="color:#f92672">.</span>Simulation(model, parameter_values<span style="color:#f92672">=</span>param, solver<span style="color:#f92672">=</span>solver)
solution <span style="color:#f92672">=</span> sim<span style="color:#f92672">.</span>solve([<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3600</span>])
</code></pre></div><p>或者直接：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">solution <span style="color:#f92672">=</span> solver<span style="color:#f92672">.</span>solve(model, t_eval)
</code></pre></div></li>
<li>
<p><strong>关键求解器选项</strong>:</p>
<ul>
<li><strong><code>method</code></strong>: (特定于求解器) 例如，对于 <code>ScipySolver</code>，可以是 <code>&quot;BDF&quot;</code>, <code>&quot;RK45&quot;</code> 等。对于 <code>CasadiSolver</code>，其内部方法（IDA/CVODES）是固定的，但可以通过 <code>mode</code> 调整行为。</li>
<li><strong><code>mode</code></strong> (<code>CasadiSolver</code> 特有):
<ul>
<li><code>&quot;safe&quot;</code> (默认): 包含额外的检查和后处理，更鲁棒。</li>
<li><code>&quot;fast&quot;</code>: 优化速度，减少检查。</li>
<li><code>&quot;fast with events&quot;</code>: 快速模式，并启用事件检测。</li>
</ul>
</li>
<li><strong><code>rtol</code> (Relative Tolerance)</strong>: 相对容差，控制解的相对精度。默认通常为 <code>1e-6</code>。</li>
<li><strong><code>atol</code> (Absolute Tolerance)</strong>: 绝对容差，控制解的绝对精度，对解接近零时尤为重要。默认通常为 <code>1e-6</code>。减小容差会提高精度但增加计算时间。</li>
<li><strong><code>t_eval</code></strong>: 用户指定需要输出解的时间点。求解器内部的时间步长可能会更小，以满足容差要求。</li>
<li><strong><code>events</code></strong>: 在模型中定义，求解器会监测这些事件。例如，<code>pybamm.Event(&quot;Minimum voltage&quot;, model.variables[&quot;Terminal voltage [V]&quot;] - model.param.lower_voltage_cut_off)</code>。当事件表达式的值穿过零时，事件被触发。</li>
<li><strong>雅可比矩阵的使用</strong>: 大多数高级求解器（尤其是隐式求解器）会利用雅可比矩阵。PyBaMM 的符号系统可以自动计算并提供这些矩阵。</li>
<li><strong>线性求解器 (<code>linsolver</code> for <code>CasadiSolver</code>)</strong>: 对于大型问题，内部线性系统的求解方式（如 <code>KLU</code>, <code>Dense</code>) 会影响性能。KLU 是稀疏线性求解器，通常更适合电池模型。</li>
</ul>
</li>
</ul>
<h2 id="6-常见问题与考量">6. 常见问题与考量</h2>
<ul>
<li><strong>模型刚性 (Stiffness)</strong>: 电池模型通常是刚性的，因为电化学反应、扩散和电荷传输等过程可能发生在非常不同的时间尺度上。刚性问题需要使用隐式求解器（如 BDF、IDA）以保证数值稳定性，显式方法（如 RK45）在刚性问题上可能需要极小的时间步长才能稳定，导致计算效率低下。个人认为，正确识别并处理模型的刚性是成功进行电池仿真的关键一步。</li>
<li><strong>收敛性问题</strong>:
<ul>
<li><strong>不一致的初始条件</strong>: DAE求解器要求初始条件必须满足所有代数约束。PyBaMM的求解器通常会自动尝试计算一致的初始条件。如果失败，可能需要用户检查模型或初始猜测。</li>
<li><strong>参数值不当</strong>: 物理上不合理的参数值可能导致模型行为极端，使求解器难以收敛。</li>
<li><strong>网格分辨率不足</strong>: 粗糙的网格可能无法捕捉关键的物理现象，导致数值不稳定或不收敛。</li>
<li><strong>容差过严</strong>: 非常严格的容差可能难以达到，尤其是在模型存在奇异点或非常剧烈的变化时。</li>
</ul>
</li>
<li><strong>计算成本</strong>:
<ul>
<li><strong>模型复杂度</strong>: 更复杂的模型（如包含更多维度、更多物理现象）自然需要更长的求解时间。</li>
<li><strong>网格点数</strong>: 求解时间通常随网格点数的增加而显著增加。</li>
<li><strong>求解器选择</strong>: <code>CasadiSolver</code> 通常比 <code>ScipySolver</code> 更快，尤其对于复杂模型。</li>
<li><strong>容差</strong>: 更宽松的容差会加快求解，但会牺牲精度。</li>
</ul>
</li>
<li><strong>调试求解问题</strong>:
<ul>
<li><strong>检查模型方程和参数</strong>: 确保模型定义正确，参数值合理。</li>
<li><strong>简化模型</strong>: 从一个更简单的模型开始，逐步增加复杂性。</li>
<li><strong>调整求解器选项</strong>: 尝试不同的求解器、更宽松的容差、不同的求解方法（如果求解器支持）。</li>
<li><strong>查看求解器统计信息</strong>: 一些求解器会返回关于步数、失败步数、雅可比计算次数等信息，有助于诊断问题。PyBaMM的 <code>Solution</code> 对象有时会包含这些信息。</li>
</ul>
</li>
</ul>
<h2 id="7-设计考量与-github-讨论">7. 设计考量与 GitHub 讨论</h2>
<p>PyBaMM 的求解器架构旨在平衡易用性、灵活性和性能。通过抽象不同求解器的接口，用户可以相对容易地切换和尝试不同的求解策略。</p>
<p>在 PyBaMM 的 GitHub 仓库中，可以找到关于求解器选择、性能优化、特定问题（如DAE初始化失败、刚性问题处理）的讨论。例如：</p>
<ul>
<li><strong>性能比较:</strong> 不同求解器在特定模型或条件下的性能基准测试。
<ul>
<li><strong>实际案例参考:</strong> Issue #88 (<a href="https://github.com/pybamm-team/PyBaMM/pull/88">Compare Casadi and Scipy performance by tinosulzer · Pull Request #88 · pybamm-team/PyBaMM</a>) 和相关的讨论提供了早期关于 CasADi 和 SciPy 求解器性能的比较，这有助于理解为什么 CasADi 后来成为默认和推荐的求解器。</li>
</ul>
</li>
<li><strong>新求解器的集成:</strong> 讨论或提议集成新的求解技术或库。
<ul>
<li><strong>实际案例参考:</strong> Issue #1023 (<a href="https://github.com/pybamm-team/PyBaMM/issues/1023">Feature Request: Add option to use JAX solver by agriya94 · Issues · pybamm-team/PyBaMM</a>) 提出了集成基于 JAX 的求解器的请求，这代表了社区对探索利用 JAX 的即时编译 (JIT) 和自动微分能力以进一步提升求解性能的兴趣。</li>
</ul>
</li>
<li><strong>特定求解器选项的调优:</strong> 关于如何为特定类型的问题设置最佳容差、步长控制参数等的建议。</li>
<li><strong>DAE 初始化策略:</strong> 改进DAE初始条件计算的讨论。
<ul>
<li><strong>实际案例参考:</strong> Issue #474 (<a href="https://github.com/pybamm-team/PyBaMM/pull/474">Consistent initial conditions for DAEs by tinosulzer · Pull Request #474 · pybamm-team/PyBaMM</a>) 关注于改进DAE一致性初始条件的计算，这对于确保DAE求解的稳定性和准确性至关重要。</li>
</ul>
</li>
</ul>
<h2 id="8-总结">8. 总结</h2>
<p>PyBaMM 的求解器子系统是其核心功能的重要组成部分，负责将离散化的数学模型转化为具体的数值解。通过集成如 CasADi、SciPy 等强大的求解库，并提供统一的接口和灵活的配置选项，PyBaMM 使用户能够有效地求解各种复杂的电池模型。理解不同求解器的特性、适用场景以及如何调整其参数，对于获得准确、高效的仿真结果至关重要。</p>
<hr>
<p><strong>下一步:</strong> <a href="./pybamm_simulation.md">仿真 (Simulation)</a></p>

		</div>
	</article>
</main>







<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
  new Valine({
      el: '#vcomments' ,
      appId: '6K1b7yCAWBISieeYhYiYm52A-gzGzoHsz',
      appKey: 'Xzo9x3Euwd2redfSk9bHafaB',
      notify: 'false', 
      verify: 'false', 
      avatar:'mm', 
      placeholder: '说点什么吧...',
      visitor: 'true'
  });
</script>

			</div>
			<aside class="sidebar">
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2025 HUA Guangbin.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> 主题</span>
            </div>
            <div style="font-size: 10px"><a href="http://beian.miit.gov.cn" target="_blank" >苏ICP备2022045537号</a>
</div>   
		</div>
	</div>
<footer>

	</div>
<script async defer src="/js/menu.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>
