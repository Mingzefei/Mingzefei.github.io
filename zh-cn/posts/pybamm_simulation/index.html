<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title> - Mingzf 的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/zh-cn" title="Mingzf 的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">Mingzf 的博客</div>
					
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">菜单</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/zh-cn/posts">
				
				<span class="menu__text">日志</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/zh-cn/about/about">
				
				<span class="menu__text">关于</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/zh-cn/about/my_cv">
				
				<span class="menu__text">简历</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/en">
				
				<span class="menu__text">English</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-26Y8LPEFKG"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-26Y8LPEFKG');
    </script>
</header>

		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title"></h1>
			
		</header>
		
<div class="post__toc toc">
	<div class="toc__title">目录</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#1-simulation-类的角色与重要性">1. <code>Simulation</code> 类的角色与重要性</a></li>
    <li><a href="#2-创建-simulation-对象">2. 创建 <code>Simulation</code> 对象</a></li>
    <li><a href="#3-运行仿真">3. 运行仿真</a>
      <ul>
        <li><a href="#31-solveself-t_evalnone-inputsnone-">3.1. <code>solve(self, t_eval=None, inputs=None, ...)</code></a></li>
        <li><a href="#32-stepself-dt-t_evalnone-npts2-inputsnone-savetrue-">3.2. <code>step(self, dt, t_eval=None, npts=2, inputs=None, save=True, ...)</code></a></li>
      </ul>
    </li>
    <li><a href="#4-仿真过程详解">4. 仿真过程详解</a></li>
    <li><a href="#5-与-solution-对象的交互">5. 与 <code>Solution</code> 对象的交互</a></li>
    <li><a href="#6-重新求解-simreset-simsolve-starting_solution">6. 重新求解 (<code>sim.reset()</code>, <code>sim.solve(..., starting_solution=...)</code>)</a></li>
    <li><a href="#7-总结">7. 总结</a></li>
  </ul>
</nav>
	</div>
</div><div class="content post__content clearfix">
			<h1 id="pybamm-核心功能仿真-simulation">PyBaMM 核心功能：仿真 (Simulation)</h1>
<p><strong>返回主目录:</strong> <a href="./pybamm_main.md">PyBaMM 项目剖析</a>
<strong>上一节:</strong> <a href="./pybamm_solvers.md">求解器 (Solvers)</a></p>
<hr>
<p>PyBaMM 中的 <code>Simulation</code> 类是用户与模型、参数、求解器和实验进行交互的主要入口点。它封装了从设置模型和参数，到运行仿真，再到获取和初步处理结果的整个工作流程。理解 <code>Simulation</code> 类及其功能对于有效使用 PyBaMM至关重要。</p>
<h2 id="1-simulation-类的角色与重要性">1. <code>Simulation</code> 类的角色与重要性</h2>
<p><code>Simulation</code> 类 (位于 <code>src/pybamm/simulation.py</code>) 旨在简化电池模型的仿真过程，提供一个高级接口来处理复杂的底层细节。其主要职责包括：</p>
<ul>
<li><strong>整合组件</strong>: 将模型 (<code>pybamm.Model</code>)、参数 (<code>pybamm.ParameterValues</code>)、实验 (<code>pybamm.Experiment</code>) 和求解器 (<code>pybamm.Solver</code>) 有效地组合在一起。</li>
<li><strong>管理仿真生命周期</strong>: 包括模型的离散化、求解过程的启动和监控、以及结果的存储。</li>
<li><strong>易用性</strong>: 提供简洁的方法如 <code>solve()</code> 和 <code>step()</code> 来运行仿真。</li>
<li><strong>灵活性</strong>: 允许用户自定义各个组件，例如选择不同的求解器或修改参数。</li>
<li><strong>结果处理</strong>: 生成的 <code>Solution</code> 对象可以直接用于数据分析和可视化。</li>
</ul>
<h2 id="2-创建-simulation-对象">2. 创建 <code>Simulation</code> 对象</h2>
<p>创建一个 <code>Simulation</code> 对象通常需要以下关键组件：</p>
<ul>
<li><strong>模型 (<code>model</code>)</strong>: 一个 <code>pybamm.BaseModel</code> 的实例，定义了电池的物理和化学行为。例如，<code>pybamm.lithium_ion.DFN()</code>。</li>
<li><strong>参数值 (<code>parameter_values</code>)</strong>: 一个 <code>pybamm.ParameterValues</code> 对象，为模型中的符号参数赋予具体的数值。通常从预定义的参数集加载并可能进行修改，例如 <code>pybamm.ParameterValues(&quot;Marquis2019&quot;)</code>。</li>
<li><strong>实验 (<code>experiment</code>)</strong> (可选): 一个 <code>pybamm.Experiment</code> 对象，定义了一系列操作步骤，如充电、放电、休息等。如果未提供，通常会执行一个简单的“求解至模型默认终止条件”的仿真。</li>
<li><strong>求解器 (<code>solver</code>)</strong> (可选): 一个 <code>pybamm.BaseSolver</code> 的实例。如果未指定，PyBaMM 会使用默认的 <code>pybamm.CasadiSolver</code>。</li>
<li><strong>其他可选参数</strong>:
<ul>
<li><code>geometry</code>: 模型的几何结构。</li>
<li><code>submesh_types</code>: 各个域的子网格类型。</li>
<li><code>var_pts</code>: 每个空间变量的网格点数。</li>
<li><code>spatial_methods</code>: 各个空间变量的离散方法。</li>
<li><code>C_rate</code>: 用于根据标称容量计算电流的 C 倍率。</li>
</ul>
</li>
</ul>
<p><strong>示例:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> pybamm

model <span style="color:#f92672">=</span> pybamm<span style="color:#f92672">.</span>lithium_ion<span style="color:#f92672">.</span>DFN()
param <span style="color:#f92672">=</span> pybamm<span style="color:#f92672">.</span>ParameterValues(<span style="color:#e6db74">&#34;Marquis2019&#34;</span>)
experiment <span style="color:#f92672">=</span> pybamm<span style="color:#f92672">.</span>Experiment(
    [
        <span style="color:#e6db74">&#34;Discharge at C/10 for 10 hours or until 3.3 V&#34;</span>,
        <span style="color:#e6db74">&#34;Rest for 1 hour&#34;</span>,
        <span style="color:#e6db74">&#34;Charge at 1 A until 4.1 V&#34;</span>,
        <span style="color:#e6db74">&#34;Hold at 4.1 V until C/50&#34;</span>,
    ]
)
solver <span style="color:#f92672">=</span> pybamm<span style="color:#f92672">.</span>CasadiSolver(mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;safe&#34;</span>)

sim <span style="color:#f92672">=</span> pybamm<span style="color:#f92672">.</span>Simulation(
    model<span style="color:#f92672">=</span>model,
    parameter_values<span style="color:#f92672">=</span>param,
    experiment<span style="color:#f92672">=</span>experiment,
    solver<span style="color:#f92672">=</span>solver,
    C_rate<span style="color:#f92672">=</span><span style="color:#ae81ff">1.0</span> <span style="color:#75715e"># 定义1C电流对应的标称容量 (个人理解：此处的C_rate是用于实验中C-rate字符串的转换，例如将&#34;C/10&#34;转换为具体电流值)</span>
)
</code></pre></div><h2 id="3-运行仿真">3. 运行仿真</h2>
<p><code>Simulation</code> 对象主要通过以下方法运行：</p>
<h3 id="31-solveself-t_evalnone-inputsnone-">3.1. <code>solve(self, t_eval=None, inputs=None, ...)</code></h3>
<p>这是最常用的方法，用于运行整个仿真（或实验的下一个步骤）。</p>
<ul>
<li><strong><code>t_eval</code></strong> (可选): 一个包含求解时间点的一维数组。
<ul>
<li>如果提供了 <code>experiment</code>，<code>t_eval</code> 通常会被忽略，因为实验定义了操作的时间和终止条件。求解器会根据实验步骤自动确定求解时长。</li>
<li>如果没有 <code>experiment</code>，<code>t_eval</code> 用于指定求解的时间区间。如果 <code>t_eval</code> 也未提供，模型通常会求解一个默认的时间段（例如，一个完整的放电周期）。</li>
</ul>
</li>
<li><strong><code>inputs</code></strong> (可选): 一个字典，用于传递外部输入（如外部电路电流、温度等）给模型。这些输入可以随时间变化。</li>
<li><strong>返回值</strong>: 一个 <code>pybamm.Solution</code> 对象，包含了仿真的结果。</li>
</ul>
<p><strong>示例:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 假设 sim 已经如上创建</span>
solution <span style="color:#f92672">=</span> sim<span style="color:#f92672">.</span>solve()
<span style="color:#75715e"># solution 对象现在包含了整个实验的结果</span>
<span style="color:#75715e"># 可以通过 solution.plot() 进行快速可视化</span>
</code></pre></div><p>如果只想求解一个简单的放电过程，不定义复杂实验：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">sim_discharge <span style="color:#f92672">=</span> pybamm<span style="color:#f92672">.</span>Simulation(model, parameter_values<span style="color:#f92672">=</span>param)
t_span <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3600</span>] <span style="color:#75715e"># 求解1小时</span>
solution_discharge <span style="color:#f92672">=</span> sim_discharge<span style="color:#f92672">.</span>solve(t_eval<span style="color:#f92672">=</span>t_span)
</code></pre></div><h3 id="32-stepself-dt-t_evalnone-npts2-inputsnone-savetrue-">3.2. <code>step(self, dt, t_eval=None, npts=2, inputs=None, save=True, ...)</code></h3>
<p>此方法用于以更小的步长推进仿真，允许用户在仿真过程中进行更细致的控制或交互。</p>
<ul>
<li><strong><code>dt</code></strong>: 要推进的时间步长。</li>
<li><strong><code>npts</code></strong>: 在 <code>dt</code> 时间段内要保存的子步数。</li>
<li><strong><code>save</code></strong>: 是否将此步骤的结果保存到 <code>sim.solution</code> 中。</li>
<li><strong>返回值</strong>: 一个 <code>pybamm.Solution</code> 对象，代表刚刚完成的这一小步的结果。</li>
</ul>
<p><code>step</code> 方法对于需要实时反馈或与其他系统集成的场景非常有用，例如在强化学习环境中控制电池充放电。</p>
<p><strong>示例:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">sim_step <span style="color:#f92672">=</span> pybamm<span style="color:#f92672">.</span>Simulation(model, parameter_values<span style="color:#f92672">=</span>param)
time_step <span style="color:#f92672">=</span> <span style="color:#ae81ff">60</span>  <span style="color:#75715e"># 每次推进60秒</span>
<span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>): <span style="color:#75715e"># 模拟10个时间步</span>
    current_solution_step <span style="color:#f92672">=</span> sim_step<span style="color:#f92672">.</span>step(dt<span style="color:#f92672">=</span>time_step)
    <span style="color:#75715e"># 可以在这里检查 current_solution_step 或 sim_step.solution</span>
    <span style="color:#75715e"># 例如：print(f&#34;Time: {sim_step.solution.t[-1]:.0f}s, Voltage: {sim_step.solution[&#39;Terminal voltage [V]&#39;].data[-1]:.2f}V&#34;)</span>
    <span style="color:#66d9ef">if</span> sim_step<span style="color:#f92672">.</span>solution<span style="color:#f92672">.</span>termination <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;event&#34;</span>:
        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Simulation stopped early due to event: </span><span style="color:#e6db74">{</span>sim_step<span style="color:#f92672">.</span>solution<span style="color:#f92672">.</span>termination_reason<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
        <span style="color:#66d9ef">break</span>
</code></pre></div><h2 id="4-仿真过程详解">4. 仿真过程详解</h2>
<p>当调用 <code>sim.solve()</code> 或 <code>sim.step()</code> 时，<code>Simulation</code> 对象内部会执行一系列操作：</p>
<ol>
<li>
<p><strong>检查和设置模型</strong>:</p>
<ul>
<li>如果模型尚未与参数值和几何结构构建（<code>sim.model.is_built</code> 为 <code>False</code>），则会使用提供的 <code>parameter_values</code> 和几何信息来构建模型。这包括设置参数、定义几何和网格。</li>
<li>如果提供了 <code>C_rate</code>，会用它来设置电流的标称值。</li>
</ul>
</li>
<li>
<p><strong>离散化</strong>:</p>
<ul>
<li>如果模型尚未离散化（<code>sim.is_discretised</code> 为 <code>False</code>），<code>Simulation</code> 会创建一个 <code>pybamm.Discretisation</code> 对象（如果用户没有提供自定义的），并使用它来将模型的偏微分方程 (PDEs) 转换为一组微分代数方程 (DAEs) 或常微分方程 (ODEs)。</li>
<li>这个过程涉及到选择空间离散方法（如有限体积法）和在每个域上应用这些方法。</li>
</ul>
</li>
<li>
<p><strong>求解</strong>:</p>
<ul>
<li><code>Simulation</code> 对象会使用指定的 <code>solver</code> (或默认求解器) 来求解离散化后的模型。</li>
<li>如果定义了 <code>experiment</code>，求解器会按照实验中定义的步骤顺序执行。每个步骤都有其自己的操作类型（如恒流、恒压）、终止条件和持续时间。</li>
<li>求解器会处理事件（如电压达到截止值），并根据实验定义决定是继续下一个步骤还是终止仿真。</li>
<li>求解过程中，求解器会与模型交互，获取方程的右端项 (<code>rhs</code>)、代数部分 (<code>algebraic</code>)、雅可比矩阵等。</li>
</ul>
</li>
<li>
<p><strong>结果存储</strong>:</p>
<ul>
<li>求解的结果（时间点、状态向量、终止原因等）被封装在一个或多个 <code>pybamm.Solution</code> 对象中。</li>
<li>如果执行的是一个完整的实验，<code>sim.solve()</code> 返回的 <code>Solution</code> 对象通常会包含所有步骤的串联结果。</li>
<li>如果使用 <code>sim.step()</code>，<code>sim.solution</code> 会累积所有已执行步骤的结果。</li>
</ul>
</li>
<li>
<p><strong>后处理 (可选)</strong>:</p>
<ul>
<li><code>Solution</code> 对象本身提供了许多后处理功能，例如通过变量名访问特定解 (<code>solution[&quot;Terminal voltage [V]&quot;]</code>)，以及内置的绘图方法 (<code>solution.plot()</code>)。</li>
</ul>
</li>
</ol>
<h2 id="5-与-solution-对象的交互">5. 与 <code>Solution</code> 对象的交互</h2>
<p><code>Simulation</code> 的 <code>solve</code> 和 <code>step</code> 方法返回 <code>pybamm.Solution</code> 对象，这是分析仿真结果的关键。</p>
<ul>
<li><strong>访问数据</strong>: <code>solution.t</code> (时间数组), <code>solution.y</code> (状态向量数组)。</li>
<li><strong>访问变量</strong>: <code>solution[variable_name]</code> 返回一个 <code>pybamm.ProcessedVariable</code> 对象，其中包含该变量在所有时间点的值 (<code>.data</code> 属性) 和对应的时间点 (<code>.t</code> 属性)。</li>
<li><strong>插值</strong>: <code>solution(t_interpolate)</code> 可以在新的时间点上插值得到解。</li>
<li><strong>事件信息</strong>: <code>solution.t_event</code>, <code>solution.y_event</code>, <code>solution.termination</code>, <code>solution.termination_reason</code>。</li>
<li><strong>绘图</strong>: <code>solution.plot(output_variables=[&quot;Terminal voltage [V]&quot;, &quot;Current [A]&quot;])</code> 可以快速可视化结果。</li>
<li><strong>保存和加载</strong>: <code>sim.save(&quot;my_simulation.pkl&quot;)</code> 可以保存整个 <code>Simulation</code> 对象（包括模型、解等），之后可以通过 <code>pybamm.load_simulation(&quot;my_simulation.pkl&quot;)</code> 加载。<code>solution.save(&quot;my_solution.pkl&quot;)</code> 或 <code>solution.save_data(&quot;my_solution_data.csv&quot;)</code> 也可以用于保存结果。</li>
</ul>
<h2 id="6-重新求解-simreset-simsolve-starting_solution">6. 重新求解 (<code>sim.reset()</code>, <code>sim.solve(..., starting_solution=...)</code>)</h2>
<ul>
<li><strong><code>sim.reset()</code></strong>: 此方法会将仿真重置到其初始状态（在离散化之后，但在任何求解发生之前）。这允许用户在不重新构建和离散化模型的情况下，使用不同的求解器选项或输入再次求解。个人认为，这对于需要多次运行相似仿真，仅改变少量参数（如求解器精度或外部输入）的场景非常有用，可以节省重复的模型构建和离散化时间。</li>
<li><strong><code>starting_solution</code></strong>: <code>solve</code> 方法接受一个 <code>starting_solution</code> 参数。如果提供，仿真将从该 <code>Solution</code> 对象的最终状态开始，而不是从模型的初始条件开始。这对于链接多个仿真或从某个保存点继续仿真非常有用。个人推测，这在模拟复杂的多阶段实验时，如果某个阶段因为某些原因中断，可以从中断前的最后一个有效解继续，而无需从头开始整个实验。</li>
</ul>
<h2 id="7-总结">7. 总结</h2>
<p><code>pybamm.Simulation</code> 类是 PyBaMM 工作流程的核心，它将模型构建、参数化、离散化、求解和基本结果处理等步骤整合到一个易于使用的接口中。通过 <code>Simulation</code> 对象，用户可以方便地设置和运行复杂的电池仿真实验，并有效地获取和分析结果。其灵活性也允许高级用户对仿真过程的各个方面进行细致的控制。</p>
<hr>
<p><strong>下一步:</strong> <a href="./pybamm_experiment.md">实验 (Experiment)</a></p>

		</div>
	</article>
</main>







<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
  new Valine({
      el: '#vcomments' ,
      appId: '6K1b7yCAWBISieeYhYiYm52A-gzGzoHsz',
      appKey: 'Xzo9x3Euwd2redfSk9bHafaB',
      notify: 'false', 
      verify: 'false', 
      avatar:'mm', 
      placeholder: '说点什么吧...',
      visitor: 'true'
  });
</script>

			</div>
			<aside class="sidebar">
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2025 HUA Guangbin.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> 主题</span>
            </div>
            <div style="font-size: 10px"><a href="http://beian.miit.gov.cn" target="_blank" >苏ICP备2022045537号</a>
</div>   
		</div>
	</div>
<footer>

	</div>
<script async defer src="/js/menu.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>
</body>
</html>
